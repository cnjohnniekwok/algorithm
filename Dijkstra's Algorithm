class SimplePriorityQueue {
    constructor() {
        this.values = [];
    }
    
    enqueue(val, priority) {
        this.values.push({val, priority})
        this.sort();
    }

    dequeue(){
        return this.values.shift(); //alway get this min value, for max .pop() 
    }

    sort(){
        this.values.sort((a,b) => a.priority - b.priority); //sprt function by priority

        //update to quick sort here for faster sort best O(log n) -> O(n^2) worst
        //sort > or < can control o(1) .pop() 
        //
    }
}

class SimpleWeightedGraph {
    constructor() {
        this.adjacencyList = {};
    }
    addVertex(vertex){
        if(!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];
    }
    addEdge(vertex1,vertex2, weight){
        this.adjacencyList[vertex1].push({node:vertex2,weight});
        this.adjacencyList[vertex2].push({node:vertex1, weight});
    }

    dijkstra(start, finish){
        const nodes = new PriorityQueue();
        const distances = {};
        const previous = {};
        
        //Initialize distances and leave start to 0 - starting point
        for(let vertex in this.adjacencyList){ //for each node of this graph
            if(vertex === start){
                distances[vertex] = 0;
                node.enqueue(vertex,0); 
            }
            else{
                distances[vertex] = Infinity
                node.enqueue(vertex,Infinity);
            }
            previous[vertex] = null;
        } // this queue will be updated later


        //every time we look to visit a new node, we pick the node with the smallest known distance to visit first

        //Once we've moved to the node we're going to visit, we look at each of its neighbors.

        //For each neighboring node, we calculate the distance by summing the total edges that lead to the node  we're checking from the starting node

        //If the new total distance to a node is less then the previous total, we store the new shorter distance for that node.

    }
}

let g = new SimpleWeightedGraph();
g.addVertex("A");
g.addVertex("B");
g.addVertex("C");
g.addVertex("D");
g.addVertex("E");
g.addVertex("F");
g.addVertex("G");